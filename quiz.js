// this module implements the server-side of quiz-question engine
//   display   : will pick apart questions dependent on type
//   grade     : grade question-answer against correct answer

var fs = require('fs');
var exec = require('child_process').exec;

function addslashes(str) {
  str=str.replace(/\\/g,'\\\\');
  str=str.replace(/\'/g,'\\\'');
  str=str.replace(/\"/g,'\\"');
  return str;
}
function stripslashes(str) {
  str=str.replace(/\\'/g,'\'');
  str=str.replace(/\\"/g,'"');
  str=str.replace(/\\\\/g,'\\');
  return str;
}

var qz = {
    quiz:{}         // cache for quiz info
 ,  question:{}     // cache for questions
 ,  symb:{}         // symbols used by dynamic question
 , perturbe:function(optionCount) {
     // gives back a shuffled string, 'abcd'.length == optionCount
     // 'abcd'  becomes 'dacb' etc - giving the order for options
     var str = '';
     var bag = 'abcdefghijklmnopqrstuvwxyz'.substr(0,optionCount); 
     // bugger them that use more options in a quiz!
     for (var i=0; i< optionCount; i++) {
       var idx = Math.floor(Math.random()*bag.length);
       var ch = bag.charAt(idx);
       bag = bag.substr(0,idx) + bag.substr(idx+1);
       str += ch;
     }
     return str;
 }
 , reorder:function(marry,str) {
     // reorders an array based on str
     // str is generated by perturbe
     var jane = [];
     for (var i=0,l=marry.length; i<l; i++) {
       var a = str.charCodeAt(i) - 97;
       jane.push(marry[a]);
     }
     return jane;
 }
 , getQobj: function(qtext) {
     var qobj = { display:'', options:[] , fasit:[] , code:'', pycode:''};
     try {
         qobj = JSON.parse(qtext);
     } catch(err) {
       console.log("getOBJ EVAL-ERROR",err,qtext);
     }
     if (qobj == undefined) {
        qobj = { display:'', options:[] , fasit:[] , code:'', pycode:''};
     }
     if (!qobj.code) qobj.code = '';
     if (!qobj.pycode) qobj.pycode = '';
     return qobj;
   }
 , stashInSymbols: function(pyout) {
     var lines = pyout.split(/\n/);
     for (var lid in lines) {
       var exp = lines[lid];
       var elm = exp.split(/=/,2);
       var sy = elm[0].replace(/ /g,'');
       if (symb[sy] != undefined ) {
         symb[sy] = (elm[1].replace(/operatorname/,'mathop'));
       }
     }
   }
  , doPyCode:function(text,uid,instance,callback) {
    if (!text || text == '') {
      callback()
    } else {
      var intro = 'from sympy import *\n';
      var now = new Date().getTime();
      fs.writeFile("/tmp/symp"+now, intro+text, function (err) {
         if (err) { res.send(''); throw err; }
           var child = exec("/usr/bin/python /tmp/symp"+now, function(error,stdout,stderr) {
             fs.unlink('/tmp/symp'+now);
             if (error) {
               console.log(error,stderr);
               callback();
             } else {
               if (stdout && stdout != '') {
                  qz.stashInSymbols(stdout);
               }
               callback();
             }
           });
      });
    }
  }
 , doCode:function(text,uid,instance) {
     if (text == '') {
       return ;
     }
     var lines = text.split(/\n/);
     for (var lid in lines) {
       var exp = lines[lid];
	     try {
	        with(symb){ eval('('+exp+')') };
	     } catch(err) {
               console.log("EVAL-ERROR",err,exp);
	     }
     }
   }
 , macro:function(text) {
     var cha = 'abcdefghijklmnopqrstuvwxyz';
     var idx = 0;
     if (!text || text == '') return text;
     text = text.replace(/\#([a-z])/g,function(m,ch) {
	     return symb[ch] || 0;
       });
     return text;
   }  
 , rlist:function(lo,hi,num) {  // random list of numbers
   // only one instance of any given number in the list
   var list = [];
   for (var i=0; i<num; i++) {
     do {
       var kand = Math.floor(lo + Math.random()*(hi+1-lo))
     } while (list.indexOf(kand) >= 0 );
     list.push(kand);
   }
   return list;
 }
 , generateParams:function(question,userid,instance,callback) {
     symb = { a:0, b:0, c:0, d:0, e:0, f:0, g:0
       , sin:Math.sin ,cos:Math.cos
       , random:Math.random, floor:Math.floor
       , rlist:qz.rlist
     };  // remove symbols from prev question
     var q = qz.question[question.id];  // get from cache
     var qobj = qz.getQobj(q.qtext);
     qz.doCode(qobj.code,userid,instance); // this is run for the side-effects (symboltabel)
        // javascript code
     // we need a callback for running python
     // this might take a while
     // returns immed if no pycode
     qz.doPyCode(qobj.pycode,userid,instance,function() {
       qobj = qz.getQobj(q.qtext);
       qobj.display = qz.macro(qobj.display);
       qobj.display = escape(qobj.display);
       for (var i in qobj.options) {
         qobj.options[i] = escape(qz.macro(qobj.options[i])); 
       }
       qobj.pycode = '';  // remove pycode and code - they are not needed in useranswer
       // only used to generate params susbtituted into display
       qobj.code = '';
       //console.log(qobj);
       switch(question.qtype) {
           case 'multiple':
             if (qobj.options && qobj.options.length) {
               qobj.optorder = qz.perturbe(qobj.options.length);
               //qobj.fasit = qz.reorder(qobj.fasit,qobj.optorder);
               qobj.fasit = '';   // don't return fasit
               qobj.options = qz.reorder(qobj.options,qobj.optorder);
             }
             break;
           case 'info':
             break;
           default:
             break;
       }
       callback(qobj);
     });
    
   }	       
 ,  display: function(qu,options) {
           // takes a question and returns a formatted display text
           // if fasit == false - remove this property
           // and also remove prop options
           //   studs may glean info from original order of
           //   options in a multiple choice question
           //   it's likely that the first option in the list is correct choice
           options = typeof(options) != 'undefined' ?  options : true;
           var qobj = qz.getQobj(qu.qtext,false);
           qobj.fasit = [];  // we never send fasit for display
           // edit question uses getquestion - doesn't involve quiz.display
           if (!options) {
             // remove options from display
             // they need to be refetched anyway
             // so that params can be used properly
             // this is needed to make dynamic questions
             // where we can instanciate a question several times on a page
             // and get different text/numbers for each instance.
             qobj.options = [];
           }
           qobj.id = qu.id;
           qobj.qtype = qu.qtype;
           qobj.points = qu.points;
           qobj.name = qu.name;
           qobj.created = qu.created;
           qobj.modified = qu.modified;
           qobj.parent = qu.parent;
           return qobj;

         }

  , grade: function(aquiz,aquest,useranswer,param) {
           // takes a question + useranswer + param and returns a grade
           // param is stored in db, it contains parameters
           // that are needed for displaying and grading the response
           // the question from db may be mangled (reordered etc) so
           // we need info about how its mangled or how dynamic content
           // has been generated 
           var qobj = qz.getQobj(aquest.qtext);
           var optorder = param.optorder;
           //console.log(param,qobj,optorder);
           var options = param.options;
           var fasit = qz.reorder(qobj.fasit,optorder);
           var qgrade = 0;
           var ua;
           try {
             eval( 'ua ='+useranswer);
           } catch(err) {
           }
           if (!ua) {
             ua = [];
           }
           switch(aquest.qtype) {
             case 'multiple':
                 //console.log(qobj,useranswer);
                 var tot = 0;      // total number of options
                 var totfasit = 0; // total of choices that are true
                 var ucorr = 0;    // user correct choices
                 var uerr = 0;     // user false choices
                 var utotch = 0;   // user total choices - should not eq tot
                 for (var ii=0,l=fasit.length; ii < l; ii++) {
                   var truthy = (fasit[ii] == '1');
                   tot++;
                   if (ua[ii]) utotch++;
                   if (truthy) totfasit++;
                   if (ua[ii] && truthy ) {
                     ucorr++;
                   } else if(!truthy  && ua[ii] ) {
                     uerr++;
                   }
                 }
                 //console.log('tot=',tot,'fasit=',totfasit,'uco=',ucorr,'uer=',uerr);
                 if (totfasit > 0) {
                   qgrade = (ucorr - uerr / 3) / totfasit;
                 }
                 if (utotch == tot) {
                   qgrade = 0;    // all options checked => no score
                 }
                 qgrade = Math.max(0,qgrade);
               break;
             case 'info':
               break;
             default:
               break;
           }
           return qgrade;
  }
}

module.exports.qz = qz;
